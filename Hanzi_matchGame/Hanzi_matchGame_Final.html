<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tr√≤ Ch∆°i K·∫øt H·ª£p Ti·∫øng Trung ƒê·ªông</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- T·∫£i th∆∞ vi·ªán Confetti JS (S·ª≠ d·ª•ng cho hi·ªáu ·ª©ng ph√°o gi·∫•y) -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
    <!-- C·∫•u h√¨nh Tailwind cho Ch·∫ø ƒë·ªô T·ªëi (Dark Mode) -->
    <script>
        tailwind.config = {
            darkMode: 'class', // B·∫≠t dark mode b·∫±ng c√°ch th√™m class="dark" v√†o th·∫ª html
            theme: {
                extend: {
                    colors: {},
                }
            }
        }
    </script>
    <!-- S·ª≠ d·ª•ng Font Mulish v√† Custom CSS -->
    <style>
        /* C·∫¨P NH·∫¨T: Thay th·∫ø Inter b·∫±ng Mulish */
        @import url('https://fonts.googleapis.com/css2?family=Mulish:wght@400;700;900&family=Noto+Sans+SC:wght@700&display=swap');
        
        body {
            font-family: 'Mulish', sans-serif; /* C·∫¨P NH·∫¨T: ƒê·∫∑t font ch·ªØ ch√≠nh l√† Mulish */
            /* M√†u n·ªÅn m·∫∑c ƒë·ªãnh (Light Mode) */
            background-color: #f7f7f7; 
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 0; 
            overflow-y: auto; 
            transition: background-color 0.3s; /* Th√™m transition cho body */
        }
        
        /* CH·∫æ ƒê·ªò T·ªêI: C·∫≠p nh·∫≠t m√†u n·ªÅn body */
        .dark body {
            background-color: #1a202c; /* M√†u n·ªÅn t·ªëi */
        }

        /* Th·∫ª tr√≤ ch∆°i */
        .card-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 6px; 
            padding: 10px; 
            background-color: #f9f9e9; /* Light mode */
            border-radius: 12px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            width: 100%; 
            aspect-ratio: 4 / 3; 
            transition: background-color 0.3s, box-shadow 0.3s;
        }
        
        /* CH·∫æ ƒê·ªò T·ªêI: C·∫≠p nh·∫≠t m√†u n·ªÅn card grid */
        .dark .card-grid {
             background-color: #2d3748; /* Darker background */
        }

        .card {
            background-color: #3b82f6; /* Blue for the back */
            border-radius: 8px;
            perspective: 1000px;
            cursor: pointer;
            transition: transform 0.6s, box-shadow 0.3s;
            position: relative;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            overflow: hidden; 
        }
        
        /* Hi·ªáu ·ª©ng l·∫≠t th·∫ª */
        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            border-radius: 8px;
        }

        .card.flipped .card-inner {
            transform: rotateY(180deg);
        }

        .card-front, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden; /* Safari */
            backface-visibility: hidden;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: 580;
            user-select: none;
            transition: background-color 0.3s, color 0.3s;
        }

        .card-back {
            background-color: #3b82f6;
            color: white;
            font-size: 2.5rem;
            line-height: 1;
        }

        .card-front {
            background-color: #ffffff; /* Light mode */
            color: #1f2937; /* Light mode */
            transform: rotateY(180deg);
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1);
        }
        
        /* CH·∫æ ƒê·ªò T·ªêI: M·∫∑t tr∆∞·ªõc th·∫ª (card-front) */
        .dark .card-front {
            background-color: #4a5568; /* Darker front */
            color: #edf2f7; /* Lighter text */
        }
        
        /* N·ªôi dung H√°n t·ª± */
        .hanzi {
            font-family: 'Kaiti','Noto Sans SC', sans-serif;
            font-size: 2.5rem;
            color: #ef4444; /* Red color for Hanzi (Light mode) */
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%; 
            width: 100%;
        }
        
        /* CH·∫æ ƒê·ªò T·ªêI: H√°n t·ª± (ch·ªâ c·∫ßn m√†u nh·∫°t h∆°n n·∫øu mu·ªën) */
        .dark .hanzi {
            color: #fca5a5; /* Red nh·∫°t h∆°n */
        }
        
        /* N·ªôi dung Pinyin / Nghƒ©a */
        .match-text {
            font-size: 1.5rem;
            color: #4b5563; /* Gray text (Light mode) */
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
        }
        
        /* CH·∫æ ƒê·ªò T·ªêI: Pinyin / Nghƒ©a */
        .dark .match-text {
            color: #cbd5e0; /* Light gray text */
        }
        
        /* N·ªôi dung H√¨nh ·∫£nh */
        .match-image {
            width: 100%;
            height: 100%;
            object-fit: cover; 
        }

        /* Tr·∫°ng th√°i ƒë√£ gh√©p ƒë√¥i */
        .card.matched {
            box-shadow: 0 0 15px rgba(6, 182, 212, 0.8);
            cursor: default;
            pointer-events: none;
            opacity: 0.8;
        }

        /* Tr·∫°ng th√°i kh√¥ng th·ªÉ t∆∞∆°ng t√°c */
        .card.disabled {
            pointer-events: none;
        }

        /* Hi·ªáu ·ª©ng G·ª£i √Ω */
        .card.hinted {
            box-shadow: 0 0 20px 4px #facc15; 
            transition: box-shadow 0.2s;
        }
        
        /* Mobile adjustments (T·ªëi ∆∞u cho m√†n h√¨nh nh·ªè) */
        @media (max-width: 640px) {
            
            .max-w-xl {
                max-width: 100%;
                padding: 5px 5px; 
            }
            
            .card-grid {
                aspect-ratio: 4 / 3; 
                gap: 5px;
                padding: 5px;
            }
            
            .card-back {
                font-size: 2rem;
            }
            .hanzi {
                font-size: 1.4rem;
            }
            .match-text {
                font-size: 0.9rem;
            }
            
             .flex-col.sm\:flex-row {
                 flex-direction: column !important;
             }
             .sm\:space-y-0 > * {
                 margin-top: 0 !important;
                 margin-bottom: 0 !important;
             }
             .flex.space-x-4 {
                 justify-content: space-between;
             }
             .flex.items-center.space-x-2 {
                 margin-top: 10px;
             }
             .w-full.sm\:w-auto {
                 width: 100%;
             }
        }
    </style>
</head>
<body class="bg-gray-100 transition-colors duration-300">
    <div class="max-w-xl w-full"> 
        <header class="text-center mb-6 p-4 relative"> 
            
            <!-- N√∫t chuy·ªÉn ƒë·ªïi ch·∫ø ƒë·ªô S√°ng/T·ªëi -->
            <button id="theme-toggle" class="absolute top-4 right-4 p-2 rounded-full bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 transition duration-300 shadow-md">
                <!-- Icon M·∫∑t tr·ªùi (Light Mode) / M·∫∑t trƒÉng (Dark Mode) - D√πng SVG ƒë·ªÉ ti·ªán cho Tailwind color change -->
                <svg id="sun-icon" class="w-6 h-6 text-yellow-500 dark:text-gray-400 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path>
                </svg>
                <svg id="moon-icon" class="w-6 h-6 text-gray-700 dark:text-yellow-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path>
                </svg>
            </button>
            
            <h1 class="text-4xl font-orange text-gray-700 dark:text-gray-200 mb-2 transition-colors duration-300">ÈÖçÂØπÊ∏∏Êàè</h1>
            <p class="text-gray-500 dark:text-gray-400 text-sm transition-colors duration-300"></p>
        </header>

        <!-- Th√™m padding/margin ngang v√†o kh·ªëi controls ƒë·ªÉ ƒë·ªìng nh·∫•t v·ªõi padding c·ªßa max-w-xl -->
        <!-- √Åp d·ª•ng dark mode cho container controls -->
        <div class="flex flex-col sm:flex-row justify-between items-start mb-4 p-4 bg-white dark:bg-gray-800 rounded-xl shadow-lg space-y-3 sm:space-y-0 sm:space-x-4 mx-2 sm:mx-0 transition-colors duration-300">
            
            <!-- C·ªôt 1: Th√¥ng tin Game -->
            <div class="flex space-x-4 w-full sm:w-auto justify-center sm:justify-start">
                <div class="text-sm font-semibold text-gray-600 dark:text-gray-300 transition-colors duration-300">
                    L∆∞·ª£t ƒëi: <span id="moves" class="text-lg text-blue-600 dark:text-blue-400">0</span>
                </div>
                <div class="text-sm font-semibold text-gray-600 dark:text-gray-300 transition-colors duration-300">
                    Th·ªùi gian: <span id="timer" class="text-lg text-red-600 dark:text-red-400">00:00</span>
                </div>
                 <!-- M·ªöI: Th√™m ƒëi·ªÉm s·ªë -->
                 <div class="text-sm font-semibold text-gray-600 dark:text-gray-300 transition-colors duration-300">
                    ƒêi·ªÉm: <span id="score" class="text-lg text-green-600 dark:text-green-400">0</span>
                </div>
            </div>

            <!-- C·ªôt 2: B·ªô ch·ªçn C·∫•p ƒë·ªô -->
            <div class="flex items-center space-x-2 w-full sm:w-auto">
                 <label for="lesson-selector" class="text-xs font-semibold uppercase text-gray-500 dark:text-gray-400 whitespace-nowrap transition-colors duration-300">B√†i h·ªçc:</label>
                <!-- C·∫≠p nh·∫≠t m√†u n·ªÅn v√† text cho selector trong dark mode -->
                <select id="lesson-selector" class="bg-gray-100 border border-gray-300 text-gray-700 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200 rounded-lg p-1.5 shadow-sm text-sm cursor-pointer w-full transition-colors duration-300">
                    <!-- Options will be loaded dynamically -->
                    <option value="loading" disabled selected>ƒêang t·∫£i...</option>
                </select>
            </div>
            
            <!-- C·ªôt 3: B·ªô ch·ªçn Ki·ªÉu Gh√©p ƒê√¥i -->
            <div class="flex items-center space-x-2 w-full sm:w-auto mt-3 sm:mt-0">
                 <label for="match-type-selector" class="text-xs font-semibold uppercase text-gray-500 dark:text-gray-400 whitespace-nowrap transition-colors duration-300">Gh√©p v·ªõi:</label>
                 <!-- C·∫≠p nh·∫≠t m√†u n·ªÅn v√† text cho selector trong dark mode -->
                <select id="match-type-selector" class="bg-gray-100 border border-gray-300 text-gray-700 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200 rounded-lg p-1.5 shadow-sm text-sm cursor-pointer w-full transition-colors duration-300">
                    <option value="pinyin">Pinyin</option>
                    <option value="vietnamese">Nghƒ©a (Ti·∫øng Vi·ªát)</option>
                    <option value="image">H√¨nh ·∫£nh</option>
                </select>
            </div>
        </div>
        
        <div class="flex justify-center mb-4 space-x-3">
             <!-- N√∫t G·ª£i √Ω m·ªõi -->
            <button id="hint-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-3 rounded-lg shadow transition disabled:opacity-50 disabled:cursor-not-allowed">
                G·ª£i √Ω (<span id="hints-left">3</span>)
            </button>
            <!-- N√∫t Ch∆°i l·∫°i -->
            <button id="restart-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow transition">
                Ch∆°i l·∫°i
            </button>
        </div>

        <!-- Game Board -->
        <div id="game-board" class="card-grid">
            <!-- Cards will be injected here by JavaScript -->
        </div>
        
        <!-- Loading Message -->
        <div id="loading-message" class="text-center text-gray-500 dark:text-gray-400 mt-4 text-sm hidden transition-colors duration-300">
             <div class="loader ease-linear rounded-full border-4 border-t-4 border-gray-200 h-8 w-8 mb-4 mx-auto"></div>
             ƒêang t·∫£i d·ªØ li·ªáu b√†i h·ªçc...
        </div>
        
        <!-- Error Message -->
        <div id="error-message" class="text-center text-red-500 mt-4 text-sm hidden transition-colors duration-300">
            L·ªói: Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu. H√£y ƒë·∫£m b·∫£o th∆∞ m·ª•c `data_matchGame` v√† c√°c t·ªáp `.txt` t·ªìn t·∫°i.
        </div>


        <!-- Win/Message Modal (d√πng overlay) -->
        <!-- C·∫≠p nh·∫≠t m√†u n·ªÅn modal cho dark mode -->
        <div id="modal-overlay" class="fixed inset-0 bg-gray-900 bg-opacity-70 flex justify-center items-center hidden transition-opacity duration-300 z-50">
            <div class="bg-white dark:bg-gray-700 p-8 rounded-xl shadow-2xl text-center max-w-sm w-full transition-colors duration-300">
                <h2 id="modal-title" class="text-3xl font-bold text-green-600 dark:text-green-400 mb-4 transition-colors duration-300">üèÜCh√∫c M·ª´ng!</h2>
                <p id="modal-message" class="text-gray-700 dark:text-gray-200 mb-6 transition-colors duration-300">
                    B·∫°n ƒë√£ ho√†n th√†nh trong: <span id="final-moves" class="font-bold text-blue-600 dark:text-blue-400">0</span> l∆∞·ª£t ƒëi,  trong <span id="final-time" class="font-bold text-red-600 dark:text-red-400">00:00</span>.
                    <br/>
                    <span class="text-xl font-extrabold text-green-600 dark:text-green-400 mt-2 block">üéØƒêi·ªÉm s·ªë: <span id="final-score">0</span></span>
                </p>
                <button id="modal-restart-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition-all">
                    Ch∆°i l·∫°i
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- C·∫•u h√¨nh Game ---
        const NUM_PAIRS = 6; // 6 c·∫∑p = 12 th·∫ª (L∆∞·ªõi 3 h√†ng x 4 c·ªôt)
        const POINTS_PER_MATCH = 20; // ƒêI·ªÇM M·ªöI: C·ªông 20 ƒëi·ªÉm khi gh√©p ƒë√¥i ƒë√∫ng
        const POINTS_PER_MISS = -5;  // ƒêI·ªÇM M·ªöI: Tr·ª´ 1 ƒëi·ªÉm khi gh√©p ƒë√¥i sai
        const FLIP_DELAY = 1000; // 1 gi√¢y
        const HINT_DURATION = 1000; // 1 gi√¢y hi·ªÉn th·ªã g·ª£i √Ω
        const MAX_HINTS = 6; // S·ªë l∆∞·ª£t g·ª£i √Ω t·ªëi ƒëa
        const BASE_DATA_PATH = './data_imgpractice/';
        
        // --- C·∫•u h√¨nh c√°c B√†i h·ªçc (Ng∆∞·ªùi d√πng c√≥ th·ªÉ t·ª± ch·ªânh s·ª≠a) ---
        const LESSON_CONFIG = [
            { id: 'bai1', name: 'B√†i 1: ËÄÅÂ∏àÊÇ®Â•ΩÔºÅ', filePath: 'bai1/bai1.txt' },
            { id: 'bai2', name: 'B√†i 2: Ë∞¢Ë∞¢‰Ω†ÔºÅ', filePath: 'bai2/bai2.txt' },
            { id: 'bai3', name: 'B√†i 3: ‰Ω†Âè´‰ªÄ‰πàÂêçÂ≠óÔºü', filePath: 'bai3/bai3.txt' },
            // TH√äM C√ÅC B√ÄI H·ªåC KH√ÅC C·ª¶A B·∫†N T·∫†I ƒê√ÇY
        ];

        let availableLessons = []; // Danh s√°ch c√°c b√†i h·ªçc c√≥ s·∫µn sau khi t·∫£i d·ªØ li·ªáu
        let gameBoard = [];
        let hasFlippedCard = false;
        let lockBoard = false;
        let firstCard = null;
        let secondCard = null;
        let matchesFound = 0;
        let moves = 0;
        let score = 0; // Bi·∫øn ƒëi·ªÉm s·ªë
        let hintsLeft = MAX_HINTS;
        
        // --- Timer Variables ---
        let timer = 0;
        let intervalId = null;
        let isRunning = false;

        // --- DOM Elements ---
        const gameBoardElement = document.getElementById('game-board');
        const movesElement = document.getElementById('moves');
        const timerElement = document.getElementById('timer');
        const scoreElement = document.getElementById('score'); // Element ƒëi·ªÉm s·ªë
        const lessonSelector = document.getElementById('lesson-selector');
        const matchTypeSelector = document.getElementById('match-type-selector'); 
        const modalOverlay = document.getElementById('modal-overlay');
        const finalMovesElement = document.getElementById('final-moves');
        const finalTimeElement = document.getElementById('final-time');
        const finalScoreElement = document.getElementById('final-score'); // Element ƒëi·ªÉm cu·ªëi c√πng
        const restartButton = document.getElementById('restart-btn');
        const modalRestartButton = document.getElementById('modal-restart-btn');
        const hintButton = document.getElementById('hint-btn');
        const hintsLeftElement = document.getElementById('hints-left');
        const loadingMessage = document.getElementById('loading-message');
        const errorMessage = document.getElementById('error-message');
        const themeToggleButton = document.getElementById('theme-toggle');
        const htmlElement = document.documentElement;
        const sunIcon = document.getElementById('sun-icon');
        const moonIcon = document.getElementById('moon-icon');


        // --- D·ªØ li·ªáu ƒë·ªông Logic ---
        
        async function loadLessonData() {
            loadingMessage.classList.remove('hidden');
            errorMessage.classList.add('hidden');
            availableLessons = [];
            
            lessonSelector.innerHTML = '<option value="loading" disabled selected>ƒêang t·∫£i...</option>';
            
            let successfulLoads = 0;
            
            for (const config of LESSON_CONFIG) {
                const dataPath = `${BASE_DATA_PATH}${config.filePath}`;
                
                try {
                    const response = await fetch(dataPath);
                    
                    if (response.ok) {
                        const text = await response.text();
                        const lines = text.trim().split('\n');
                        
                        const vocabulary = lines.map(line => {
                            const parts = line.split('|');
                            if (parts.length === 3) {
                                return {
                                    hanzi: parts[0].trim(),
                                    pinyin: parts[1].trim(),
                                    vietnamese: parts[2].trim(),
                                    imagePath: `${BASE_DATA_PATH}${config.id}/img/${parts[0].trim()}.jpg` 
                                };
                            }
                            return null;
                        }).filter(item => item !== null);

                        if (vocabulary.length > 0) {
                            availableLessons.push({
                                id: config.id,
                                name: `${config.name}`, 
                                vocabulary: vocabulary 
                            });
                            successfulLoads++;
                        }
                    } else {
                        console.warn(`Kh√¥ng th·ªÉ t·∫£i t·ªáp d·ªØ li·ªáu cho b√†i h·ªçc ${config.name} (${dataPath}). M√£ l·ªói: ${response.status}`);
                    }
                } catch (error) {
                    console.error(`L·ªói k·∫øt n·ªëi khi t·∫£i d·ªØ li·ªáu cho b√†i h·ªçc ${config.name}:`, error.message);
                }
            }

            lessonSelector.innerHTML = '';

            if (successfulLoads > 0) {
                availableLessons.forEach(lesson => {
                    const option = document.createElement('option');
                    option.value = lesson.id; 
                    option.textContent = lesson.name;
                    lessonSelector.appendChild(option);
                });
                
                lessonSelector.value = availableLessons[0].id;
                loadingMessage.classList.add('hidden');
                startGame(); 
            } else {
                 errorMessage.textContent = "Kh√¥ng t√¨m th·∫•y b·∫•t k·ª≥ t·ªáp d·ªØ li·ªáu b√†i h·ªçc n√†o c√≥ t·ª´ v·ª±ng. Vui l√≤ng ki·ªÉm tra l·∫°i LESSON_CONFIG, ƒë∆∞·ªùng d·∫´n, v√† ƒë·ªãnh d·∫°ng t·ªáp .txt.";
                 errorMessage.classList.remove('hidden');
                 loadingMessage.classList.add('hidden');
                 gameBoardElement.innerHTML = `<div class="text-center w-full col-span-4 text-red-500 p-8">L·ªói: Kh√¥ng th·ªÉ t·∫£i t·ª´ v·ª±ng. Vui l√≤ng xem console ƒë·ªÉ bi·∫øt chi ti·∫øt l·ªói t·∫£i t·ªáp.</div>`;
            }
        }
        
        function getCurrentVocabulary() {
            const selectedId = lessonSelector.value;
            const lesson = availableLessons.find(l => l.id === selectedId);
            return lesson ? lesson.vocabulary : [];
        }

        function getCurrentLessonId() {
            return lessonSelector.value;
        }

        // --- Audio Logic (MP3 First, then Web Speech API) ---
        
        function speakChineseFallback(text) {
            if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel();
                const utterance = new SpeechSynthesisUtterance(text);
                
                const chineseVoice = window.speechSynthesis.getVoices().find(
                    voice => voice.lang === 'zh-CN' || voice.lang.startsWith('zh-')
                );
                
                if (chineseVoice) {
                    utterance.voice = chineseVoice;
                } else {
                    utterance.lang = 'zh-CN'; 
                }
                utterance.rate = 0.9; 
                window.speechSynthesis.speak(utterance);
            } else {
                console.warn('Web Speech API kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£ tr√™n tr√¨nh duy·ªát n√†y.');
            }
        }

        function speakChinese(text) {
            const lessonId = getCurrentLessonId();
            const audioPath = `${BASE_DATA_PATH}${lessonId}/mp3/${text}.mp3`;
            
            const audio = new Audio(audioPath);
            
            let hasTriedFallback = false;

            const tryFallback = () => {
                if (!hasTriedFallback) {
                    hasTriedFallback = true;
                    console.warn(`Kh√¥ng t√¨m th·∫•y ho·∫∑c kh√¥ng th·ªÉ ph√°t t·ªáp MP3 cho "${text}" (${audioPath}). S·ª≠ d·ª•ng Web Speech API.`);
                    speakChineseFallback(text);
                }
            };

            audio.onerror = () => {
                tryFallback();
            };

            audio.oncanplaythrough = () => {
                audio.play().catch(e => {
                    console.error(`L·ªói khi c·ªë g·∫Øng ph√°t audio MP3: ${e.message}`);
                    tryFallback();
                });
            };

            setTimeout(() => {
                if (audio.readyState === 0 || audio.paused) {
                    tryFallback();
                }
            }, 1500);
        }

        // --- Timer Logic ---
        
        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        function updateTimer() {
            timerElement.textContent = formatTime(timer);
        }

        function startTimer() {
            if (isRunning) return;
            isRunning = true;
            intervalId = setInterval(() => {
                timer++;
                updateTimer();
            }, 1000);
        }

        function stopTimer() {
            if (!isRunning) return;
            isRunning = false;
            clearInterval(intervalId);
        }
        
        // --- Game Logic ---
        
        function shuffleArray(array) {
            const shuffled = [...array]; 
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function initializeBoard() {
            const vocab = getCurrentVocabulary(); 
            
            if (vocab.length === 0) {
                 console.error("Kh√¥ng c√≥ t·ª´ v·ª±ng ƒë·ªÉ t·∫°o th·∫ª. D·ª´ng kh·ªüi t·∫°o board.");
                 gameBoard = [];
                 return;
            }
            
            const shuffledVocab = shuffleArray(vocab);
            const pairsData = shuffledVocab.slice(0, NUM_PAIRS);
            const matchType = matchTypeSelector.value;

            const getMatchContent = (item, type) => {
                switch (type) {
                    case 'pinyin': return item.pinyin;
                    case 'vietnamese': return item.vietnamese;
                    case 'image': return item.imagePath;
                    default: return '';
                }
            };
            
            const pairs = pairsData.flatMap((item, index) => [
                { id: index, content: item.hanzi, type: 'hanzi', originalWord: item.hanzi },
                { id: index, content: getMatchContent(item, matchType), type: matchType, originalWord: item.hanzi }
            ]);

            const finalShuffledBoard = shuffleArray(pairs);

            gameBoard = finalShuffledBoard;
            matchesFound = 0;
            moves = 0;
            score = 0; // ƒê·∫∑t l·∫°i ƒëi·ªÉm s·ªë
            hintsLeft = MAX_HINTS;
        }

        function renderBoard() {
            if (gameBoard.length === 0) {
                 gameBoardElement.innerHTML = '';
                 return;
            }

            gameBoardElement.innerHTML = '';
            movesElement.textContent = moves;
            scoreElement.textContent = score; // Hi·ªÉn th·ªã ƒëi·ªÉm s·ªë
            hintsLeftElement.textContent = hintsLeft;
            updateTimer();
            
            hintButton.disabled = hintsLeft <= 0; 

            gameBoard.forEach((cardData, index) => {
                const cardElement = document.createElement('div');
                cardElement.classList.add('card');
                cardElement.dataset.id = cardData.id;
                cardElement.dataset.index = index;
                cardElement.dataset.originalWord = cardData.originalWord; 
                cardElement.dataset.type = cardData.type; 

                let contentHTML = '';
                
                if (cardData.type === 'hanzi') {
                    contentHTML = `<div class="hanzi">${cardData.content}</div>`;
                } else if (cardData.type === 'image') {
                    contentHTML = `<img src="${cardData.content}" class="match-image" alt="${cardData.originalWord}" onerror="this.onerror=null;this.outerHTML='<div class=\\'match-text\\'>·∫¢nh kh√¥ng t·ªìn t·∫°i</div>';" />`;
                } else {
                    contentHTML = `<div class="match-text">${cardData.content}</div>`;
                }

                cardElement.innerHTML = `
                    <div class="card-inner">
                        <div class="card-back flex justify-center items-center">?</div>
                        <div class="card-front">${contentHTML}</div>
                    </div>
                `;

                cardElement.addEventListener('click', () => flipCard(cardElement));
                gameBoardElement.appendChild(cardElement);
            });
        }
        
        function flipCard(card) {
            if (matchesFound === 0 && moves === 0 && !hasFlippedCard) {
                 startTimer();
            }

            if (lockBoard) return;
            if (card === firstCard) return; 
            if (card.classList.contains('matched') || card.classList.contains('flipped')) return;

            card.classList.add('flipped');

            if (!hasFlippedCard) {
                hasFlippedCard = true;
                firstCard = card;
                return;
            }

            secondCard = card;
            moves++;
            movesElement.textContent = moves;

            checkForMatch();
        }

        function checkForMatch() {
            const isMatch = firstCard.dataset.id === secondCard.dataset.id;

            if (isMatch) {
                // ƒêI·ªÇM M·ªöI: C·ªông 20 ƒëi·ªÉm
                score += POINTS_PER_MATCH; 
                scoreElement.textContent = score;
                disableCards(); 
            } else {
                // ƒêI·ªÇM M·ªöI: Tr·ª´ 1 ƒëi·ªÉm
               if(score>0){
                score += POINTS_PER_MISS; 
                }
                scoreElement.textContent = score;
                unflipCards();
            }
        }

        function disableCards() {
            firstCard.classList.add('matched');
            secondCard.classList.add('matched');
            
            matchesFound++;
            
            speakChinese(firstCard.dataset.originalWord);

            checkWinCondition();
            
            resetBoard(); 
        }

        function unflipCards() {
            lockBoard = true; 
            
            setTimeout(() => {
                if (firstCard && secondCard) {
                    firstCard.classList.remove('flipped');
                    secondCard.classList.remove('flipped');
                }
                lockBoard = false; 
                
                resetBoard();
            }, FLIP_DELAY);
        }

        function resetBoard() {
            [hasFlippedCard, lockBoard] = [false, false];
            [firstCard, secondCard] = [null, null];
            hintButton.disabled = hintsLeft <= 0 || lockBoard; 
        }
        
        /**
         * Logic b·∫Øn ph√°o gi·∫•y 3 l·∫ßn
         */
        function launchConfetti() {
            const defaults = {
                origin: { y: 0.7 }
            };

            function fire(particleRatio, opts) {
                confetti(Object.assign({}, defaults, opts, {
                    particleCount: Math.floor(200 * particleRatio)
                }));
            }

            // B·∫Øn 3 l·∫ßn li√™n ti·∫øp
            fire(0.25, {
                spread: 26,
                startVelocity: 55,
            });
            fire(0.2, {
                spread: 60,
            });
            fire(0.35, {
                spread: 100,
                decay: 0.91,
                scalar: 0.8
            });
            fire(0.1, {
                spread: 120,
                startVelocity: 25,
                decay: 0.92,
                scalar: 1.2
            });
            fire(0.1, {
                spread: 120,
                startVelocity: 45,
            });
        }
        
        function checkWinCondition() {
            if (matchesFound === NUM_PAIRS) {
                stopTimer();
                launchConfetti(); // B·∫ÆN PH√ÅO GI·∫§Y
                showModal(moves, timer, score); // Truy·ªÅn ƒëi·ªÉm s·ªë v√†o modal
            }
        }
        
        function useHint() {
            if (hintsLeft <= 0 || lockBoard || hasFlippedCard) return;

            stopTimer(); 
            
            hintsLeft--;
            hintsLeftElement.textContent = hintsLeft;
            hintButton.disabled = true;
            lockBoard = true;

            const unmatchedCards = Array.from(gameBoardElement.querySelectorAll('.card:not(.matched):not(.flipped)'));
            
            if (unmatchedCards.length < 2) {
                lockBoard = false;
                hintButton.disabled = hintsLeft <= 0;
                if (matchesFound < NUM_PAIRS) startTimer();
                return;
            }
            
            const randomIndex = Math.floor(Math.random() * unmatchedCards.length);
            const card1 = unmatchedCards[randomIndex];
            const matchingCardId = card1.dataset.id;

            const card2 = unmatchedCards.find(card => card !== card1 && card.dataset.id === matchingCardId);
            
            if (!card2) {
                lockBoard = false;
                hintButton.disabled = hintsLeft <= 0;
                if (matchesFound < NUM_PAIRS) startTimer();
                return;
            }

            card1.classList.add('flipped', 'hinted', 'disabled');
            card2.classList.add('flipped', 'hinted', 'disabled');

            setTimeout(() => {
                card1.classList.remove('flipped', 'hinted', 'disabled');
                card2.classList.remove('flipped', 'hinted', 'disabled');
                lockBoard = false;
                hintButton.disabled = hintsLeft <= 0;
                if (matchesFound < NUM_PAIRS) startTimer();
            }, HINT_DURATION);
        }


        /**
         * Hi·ªÉn th·ªã modal ch√∫c m·ª´ng chi·∫øn th·∫Øng, bao g·ªìm ƒëi·ªÉm s·ªë.
         */
        function showModal(finalMoves, finalTime, finalScore) {
            finalMovesElement.textContent = finalMoves;
            finalTimeElement.textContent = formatTime(finalTime);
            finalScoreElement.textContent = finalScore; // Hi·ªÉn th·ªã ƒëi·ªÉm s·ªë cu·ªëi c√πng
            modalOverlay.classList.remove('hidden');
        }
        
        function startGame() {
            const vocab = getCurrentVocabulary(); 
            timer=0;
            if (vocab.length === 0) {
                 gameBoardElement.innerHTML = `<div class="text-center w-full col-span-4 text-red-500 p-8">B√†i h·ªçc n√†y kh√¥ng c√≥ t·ª´ v·ª±ng ho·∫∑c d·ªØ li·ªáu b·ªã l·ªói. Vui l√≤ng ch·ªçn b√†i h·ªçc kh√°c.</div>`;
                 stopTimer();
                 return;
            }
            
            stopTimer(); 
            modalOverlay.classList.add('hidden');
            initializeBoard(); 
            renderBoard();
            resetBoard(); 
            
            timerElement.textContent = formatTime(0);
        }

        // --- Logic Chuy·ªÉn ƒë·ªïi Ch·∫ø ƒë·ªô S√°ng/T·ªëi ---
        
        function updateThemeIcons(isDark) {
            if (isDark) {
                sunIcon.classList.remove('hidden');
                moonIcon.classList.add('hidden');
            } else {
                sunIcon.classList.add('hidden');
                moonIcon.classList.remove('hidden');
            }
        }

        function applyTheme(isDark) {
            if (isDark) {
                htmlElement.classList.add('dark');
                localStorage.setItem('theme', 'dark');
            } else {
                htmlElement.classList.remove('dark');
                localStorage.setItem('theme', 'light');
            }
            updateThemeIcons(isDark);
        }

        function toggleTheme() {
            const isDark = htmlElement.classList.contains('dark');
            applyTheme(!isDark);
        }

        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            let shouldBeDark;
            if (savedTheme) {
                shouldBeDark = savedTheme === 'dark';
            } else {
                shouldBeDark = prefersDark;
            }
            
            applyTheme(shouldBeDark);
        }

        // --- Initialization ---

        function initializeApp() {
            initializeTheme();

            loadLessonData();
            
            restartButton.addEventListener('click', startGame);
            modalRestartButton.addEventListener('click', startGame);
            hintButton.addEventListener('click', useHint);
            lessonSelector.addEventListener('change', startGame); 
            matchTypeSelector.addEventListener('change', startGame);
            
            themeToggleButton.addEventListener('click', toggleTheme);
        }

        document.addEventListener('DOMContentLoaded', () => {
             if ('speechSynthesis' in window && !window.speechSynthesis.getVoices().length) {
                 window.speechSynthesis.onvoiceschanged = initializeApp;
             } else {
                 initializeApp();
             }
        });

    </script>
</body>
</html>
